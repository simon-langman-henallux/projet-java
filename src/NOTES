// TODO affichage statistiques
// TODO affichage commande
// TODO passage de commande
// TODO champs non modifiable dans les formulaires
// TODO déplacer code de CountryDAO dans autre classe car classes supp. inutiles

A AMELIORER ?

- dans la liste de commandes, afficher le nom du client plutot que son id.




PREPA QUESTION POUR EXAM
- design pattern SingletonConnection, DAO
- les couches (dataAccess, business, exception, etc...)
- 2 constructeurs ds Person mais pas dans Game et Document ? car l'identifiant de Peerson est auto-incrémenté donc dans les insert pas besoin de récupérer l'insert, mais dans Game et Document si.
- Service Layer Pattern (méthode validate dans GameService, etc)
- c'est quoi acrhitecture 3-tiers ?
- le design pattern DAO doit attraper les SQLExceptions dans les DAO pq ? c'est quoi le découplage des couches ? c'est quoi remonter les exceptions ?
- à quoi sert le package controller ? d'un point de vue de design pattern ?
- sérialisation des données ? utile dans ce projet ?

//ordre de travail : model → exception → dataAccess → business → controller → view → Launcher
// !!!!! gérer la suppression des jeux et personnes avec les documents.


Couche présentation (UI / IHM)

    Affiche les données à l’utilisateur et récupère ses actions (clics, saisies…).

    Ne contient pas de logique métier ni d’accès direct à la base.

    Exemple : fenêtres Swing, pages web, formulaires.

Couche métier (Business / Service)

    Contient les règles et traitements spécifiques au domaine du projet.

    Décide comment manipuler les données.

    Exemple : calcul d’un prix, validation d’une commande.

Couche d’accès aux données (DAO / Repository)

    Gère la communication avec la base de données ou d’autres sources de données.

    Effectue les opérations CRUD (create, read, update, delete).

    Exemple : GameDAO, PersonDAO.

Couche modèle (Model / Entities)

    Définit les objets qui représentent les données manipulées par l’application.

    Sert de lien entre la base et les autres couches.

    Exemple : classe Game avec id, title, platform.


sert à quoi ? :

1. business : classes services => vérifie les entrées, fais les calculs, conversion. transforme les données pour le controller.
2. controller : fait le pont entre services et view, récupère les valeurs de la view et pousser les résultats dans la view.


- pourquoi des interfaces dans dataAccess ?

sert à définir les opérations CRUD que la couche business est autorisée à appeler.
permet de facilement changer l'implémentation de la couche dataAccess
en modifiant le moins possible le code dans business (découplage de couches).

- que font les classes concrètes ?

elle implémentent les interfaces, ouvre la connexion à la DB, PREPARENT LES REQUÊTES et gestion des exceptions + mapping des resultset

ordre d'implémentation des classes :

| Ordre | Classe              | Pourquoi commencer par elle                       |
| ----- | ------------------- | ------------------------------------------------- |
| 1     | `WelcomePanel`      | Écran d'accueil, sans dépendances                 |
| 2     | `LauncherWindow`    | Fenêtre principale avec menus                     |
| 3     | `AddGamePanel`      | Premier formulaire CRUD (le plus simple à tester) |
| 4     | `ListGamePanel`     | Affiche + supprime + permet modification          |
| 5     | `AddPersonPanel`    | Même logique, une fois Game maîtrisé              |
| 6     | `ListPersonPanel`   | Affichage et gestion de Person                    |
| 7     | `SearchByGamePanel` | Recherche simple avec combo jeux                  |
| 8     | `SearchByDatePanel` | Recherche avec combo client + `JSpinner` date     |
| 9     | `SearchByAgePanel`  | Recherche avec combo pays + `JSpinner` âge        |
| 10    | `AnimatedLogoPanel` | Thread indépendant (aucune dépendance métier)     |